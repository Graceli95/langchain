---
alwaysApply: true
---
# LangChain & LangGraph v1.0 Development Guidelines

**You will deliver the best, most up-to-date LangChain v1.0 code.** 

This rule ensures all LangChain and LangGraph code is built using the **latest v1.0 documentation** and best practices. The user can trust that you're using current patterns, not deprecated approaches.

## Pre-Development Documentation Check

**MANDATORY**: **ALWAYS** search the web for current documentation **BEFORE** writing any LangChain or LangGraph code.

### Why This Matters:
- LangChain v1.0 introduced **major breaking changes** from v0.x
- Outdated patterns (like `create_react_agent`, LCEL chains, etc.) **will not work**
- The user deserves **current, working code**, not deprecated examples

### Required Steps:

1. **Search for Latest Documentation (MANDATORY):**
   - **ALWAYS** use `@Web` to search for current documentation
   - Primary source: https://docs.langchain.com/oss/python/langchain
   - Search query format: `"LangChain v1.0 [specific feature] site:docs.langchain.com"`
   - Examples:
     - `"LangChain v1.0 create_agent site:docs.langchain.com"`
     - `"LangGraph v1.0 StateGraph workflow site:docs.langchain.com"`
     - `"LangChain v1.0 vector stores site:docs.langchain.com"`

2. **Verify Breaking Changes:**
   - Check for v0.x to v1.0 migration notes
   - Identify deprecated APIs or patterns (create_react_agent, LCEL, etc.)
   - Look for new recommended approaches

3. **Challenge Your Assumptions:**
   - If you think you know the API, **search anyway**
   - APIs change frequently - don't rely on training data
   - When in doubt, search it out!

4. **Document Your Research:**
   - Add a comment block at the top of new files:
     ```python
     """
     LangChain Version: v1.0+
     Documentation Reference: [URL from web search]
     Last Verified: [DATE]
     """
     ```

## LangChain v1.0 Best Practices

### Imports and Versions
```python
# Always use explicit version checking when critical
from langchain import __version__
# Target: v1.0+
# Documentation checked: [DATE]
# Reference: [URL]
```

### Core Architecture Changes in v1.0
**IMPORTANT:** LangChain Expression Language (LCEL) has been **deprecated and removed** in v1.0.

### Simplicity First: Use Built-in Helper Functions
**KEY PRINCIPLE:** Start simple, only go complex when needed. The user deserves clean, maintainable code.

LangChain v1.0 provides **high-level helper functions** for common tasks:
- ‚úÖ **ALWAYS PREFER**: `create_agent()` for standard agents (from `langchain.agents`)
- ‚úÖ **ALWAYS PREFER**: Built-in functions like `init_chat_model()` 
- ‚úÖ **ALWAYS PREFER**: Simple, direct APIs over manual graph construction
- ‚úÖ **KEEP IT SIMPLE**: Avoid unnecessary wrapper functions or abstractions

**Only use manual LangGraph StateGraph when you need:**
- Custom nodes or workflow logic beyond standard agent patterns
- Multi-agent coordination
- Human-in-the-loop patterns
- Complex routing, cycles, or branching logic
- Custom state transformations

**DO NOT use manual LangGraph for:**
- ‚ùå Simple single agents (use `create_agent()` instead)
- ‚ùå Basic tool-calling workflows (use `create_agent()` instead)
- ‚ùå Straightforward Q&A bots (use `create_agent()` instead)

### Simple Agent Creation (ALWAYS START HERE)

**This is the v1.0 standard.** Use this pattern for 90% of agent needs:

```python
from langchain.agents import create_agent
from langchain_core.tools import tool

@tool
def my_tool(query: str) -> str:
    """My tool description."""
    return "result"

# That's it! Just 4 lines for a fully working agent.
agent = create_agent(
    model="openai:gpt-4o-mini",  # Simple string format
    tools=[my_tool],
    system_prompt="You are a helpful assistant."
)

# Use it:
result = agent.invoke({"messages": [{"role": "user", "content": "Hello"}]})
```

**Key Benefits:**
- ‚úÖ Simple and readable
- ‚úÖ Built on LangGraph under the hood (gets all the benefits)
- ‚úÖ Handles tool calling, state management, and message history automatically
- ‚úÖ Production-ready out of the box

### Advanced: Manual LangGraph (Only When Necessary)
When you need custom workflow control:
```python
from langgraph.graph import StateGraph
from typing import TypedDict

class State(TypedDict):
    input: str
    output: str

workflow = StateGraph(State)
workflow.add_node("process", process_function)
workflow.set_entry_point("process")
app = workflow.compile()
```

### Standardized Model Interface
- LangChain v1.0 introduces a unified model interface
- Consistent API across different LLM providers
- Use `.invoke()`, `.batch()`, `.stream()` methods consistently
- Leverage async methods when available (`.ainvoke()`, `.abatch()`)

### Vector Stores and Retrievers
- Use the latest vectorstore implementations
- Implement proper metadata filtering
- Use `.as_retriever()` method for integration with workflows
- Integrate retrievers as nodes in LangGraph workflows

### Memory and Chat History
- Implement memory as part of LangGraph state
- Use persistent state management for conversations
- Avoid legacy memory abstractions like `ConversationBufferMemory`

### Agents and Tools
- **PREFER**: Use `create_agent()` from `langchain.agents` for standard agents
- Define tools using the `@tool` decorator
- Implement proper error handling and fallbacks
- Use structured output parsing with Pydantic models
- Only use manual LangGraph StateGraph for complex custom workflows

## Code Review Checklist

Before committing LangChain/LangGraph code, verify:

- [ ] Latest v1.0 documentation was consulted (web search performed)
- [ ] No deprecated v0.x patterns are used (especially LCEL)
- [ ] **Used simplest approach first** (helper functions before manual graphs)
- [ ] No LCEL pipe operators (`|`) or legacy chain patterns
- [ ] Proper async/await patterns implemented if needed
- [ ] Error handling includes LangChain-specific exceptions
- [ ] Type hints are used throughout
- [ ] Pydantic models used for structured I/O
- [ ] Documentation comments reference specific v1.0 docs
- [ ] Environment variables properly configured (API keys, etc.)
- [ ] Rate limiting and cost management considered

## Common Migration Issues (v0.x ‚Üí v1.0)

Watch out for these breaking changes:

1. **LCEL Removal (CRITICAL):**
   - ‚ùå Deprecated: All LCEL patterns including pipe operator (`|`)
   - ‚ùå Deprecated: `prompt | llm | output_parser`
   - ‚úÖ New: Use helper functions OR LangGraph for custom workflows

2. **Chain Construction:**
   - ‚ùå Old: `LLMChain(llm=llm, prompt=prompt)`
   - ‚ùå Old: Any LCEL chain patterns
   - ‚úÖ New: For simple cases, use direct model invocation
   - ‚úÖ New: For complex workflows, use LangGraph StateGraph

3. **Agent Creation:**
   - ‚ùå **DEPRECATED**: `initialize_agent(...)` (removed in v1.0)
   - ‚ùå **DEPRECATED**: `create_react_agent(...)` (removed in v1.0)
   - ‚ùå **DEPRECATED**: Any reference to "ReAct" agents (terminology no longer used)
   - ‚ùå **WRONG**: Manual LangGraph StateGraph for simple agents
   - ‚úÖ **CORRECT**: `create_agent()` from `langchain.agents` (current v1.0 standard)
   - ‚úÖ **ADVANCED**: Manual LangGraph StateGraph ONLY for complex custom workflows
   
   **Example (simple agent - use this 90% of the time):**
   ```python
   from langchain.agents import create_agent
   
   agent = create_agent(
       model="openai:gpt-4o-mini",
       tools=[my_tool],
       system_prompt="You are helpful."
   )
   ```

4. **Memory:**
   - ‚ùå Old: `ConversationBufferMemory`
   - ‚ùå Old: `RunnableWithMessageHistory`
   - ‚úÖ New: State management within LangGraph workflows

5. **Output Parsing:**
   - ‚ùå Old: Custom string parsing
   - ‚úÖ New: Structured output with `.with_structured_output()` and Pydantic
   - ‚úÖ New: Parse nodes in LangGraph workflows

6. **Callbacks:**
   - ‚ùå Old: Direct callback handlers
   - ‚úÖ New: LangGraph persistence and checkpoint system

## Testing Requirements

All LangChain/LangGraph code must include:

- Unit tests with mocked LLM responses
- Integration tests with actual API calls (in separate test suite)
- Error handling tests (rate limits, API failures, malformed responses)
- Token usage and cost estimation validation

## Documentation Requirements

Each LangChain/LangGraph module must have:

```python
"""
Module: [module_name]
Purpose: [brief description]

LangChain Version: v1.0+
Documentation Reference: [URL]
Last Updated: [DATE]

Key Components:
- [Component 1]: [description]
- [Component 2]: [description]

Dependencies:
- langchain>=1.0.0
- langchain-community>=1.0.0
- [other specific packages]
"""
```

## AI Assistant Instructions

**You are committed to delivering the best possible LangChain v1.0 code.** The user trusts you to use current patterns.

### Mandatory Workflow:

1. **üîç SEARCH FIRST (REQUIRED):**
   - **ALWAYS** use `@Web` to search for current documentation
   - Query: `"LangChain v1.0 [feature] site:docs.langchain.com"`
   - **DO NOT** skip this step, even if you think you know the API
   - **VERIFY** your assumptions against live documentation

2. **üéØ START SIMPLE:**
   - Check if there's a built-in helper function first
   - For agents: Use `create_agent()` - don't manually build LangGraph
   - For models: Use `init_chat_model()` - don't manually instantiate
   - For standard patterns: Use helper functions - don't reinvent wheels
   
3. **‚ö†Ô∏è CHALLENGE YOURSELF:**
   - If your solution feels complex, search for a simpler approach
   - If you're writing >20 lines for a basic agent, you're probably overcomplicating it
   - If you're tempted to use LangGraph StateGraph for a simple agent, **STOP** and use `create_agent()`

4. **üö´ ONLY GO COMPLEX WHEN:**
   - User explicitly requests custom workflow logic
   - Building multi-agent systems with complex coordination
   - Need features genuinely not available in helper functions
   - Implementing advanced patterns (human-in-the-loop, custom routing)

5. **üìö EXPLAIN YOUR RESEARCH:**
   - Share what you learned from the documentation
   - Cite specific documentation URLs
   - Explain why you chose this approach over alternatives

6. **üö© FLAG CONCERNS:**
   - If documentation is unclear or conflicting, mention it
   - If you're uncertain, admit it and suggest verification
   - If breaking changes might affect existing code, warn the user

7. **üí° KISS Principle (Keep It Simple, Stupid):**
   - Prefer readability over cleverness
   - Prefer built-in functions over manual construction
   - Avoid unnecessary wrapper functions or abstractions
   - Only add complexity when there's a clear, documented benefit
   - Linear, top-to-bottom code flow is better than nested functions

8. **‚úÖ QUALITY ASSURANCE:**
   - Include helpful comments explaining what each section does
   - Add type hints for clarity
   - Handle errors gracefully
   - Test with realistic examples

## Resources

All v1.0 documentation is hosted at docs.langchain.com:

- **Primary Docs**: https://docs.langchain.com/
- **LangChain (Python)**: https://docs.langchain.com/oss/python/langchain
- **LangGraph (Python)**: https://docs.langchain.com/oss/python/langgraph
- **Migration to v1.0**: https://docs.langchain.com/oss/python/migrate/langgraph-v1
- **LangSmith Platform**: https://docs.langchain.com/langsmith
- **MCP Server** (Programmatic Access): https://docs.langchain.com/mcp
- **GitHub**: https://github.com/langchain-ai/langchain

## Trust & Quality Commitment

**The user can trust that you will:**
- ‚úÖ Always search for current documentation before coding
- ‚úÖ Use the simplest approach that solves the problem
- ‚úÖ Deliver v1.0-compliant code, not deprecated patterns
- ‚úÖ Explain your approach and cite documentation sources
- ‚úÖ Flag any uncertainties or potential issues
- ‚úÖ Write clean, maintainable, well-commented code
- ‚úÖ Follow KISS principles - no unnecessary complexity

**You will NOT:**
- ‚ùå Use deprecated APIs (LCEL, create_react_agent, etc.)
- ‚ùå Overcomplicate simple problems
- ‚ùå Guess at APIs - always verify with web search
- ‚ùå Write manual LangGraph for basic agents
- ‚ùå Create unnecessary wrapper functions or abstractions

## Version Tracking

This rule was created for LangChain v1.0+ (October 2024 onwards)  
Last updated: October 23, 2025  
**Rule validated against live documentation: YES** ‚úÖ
